-- -------------------------------------------------------------
-- 
-- File Name: /u/home/eraguzin/matlab/LNspec/matlab/codegen/cal_average_instance_C1/hdlsrc/cal_average_instance_C1_fixpt_tb.vhd
-- Created: 2023-11-22 12:29:59
-- 
-- Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- outreal                       ce_out        1
-- outimag                       ce_out        1
-- powertop                      ce_out        1
-- powerbot                      ce_out        1
-- drift_FD                      ce_out        1
-- drift_SD                      ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cal_average_instance_C1_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.cal_average_instance_C1_fixpt_pkg.ALL;
USE work.cal_average_instance_C1_fixpt_tb_pkg.ALL;

ENTITY cal_average_instance_C1_fixpt_tb IS
END cal_average_instance_C1_fixpt_tb;


ARCHITECTURE rtl OF cal_average_instance_C1_fixpt_tb IS

  -- Component Declarations
  COMPONENT cal_average_instance_C1_fixpt
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          real_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En30
          imag_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En30
          calbin                          :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          phase_cor_re                    :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En30
          phase_cor_im                    :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En30
          kar                             :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          tick                            :   IN    std_logic_vector(1 DOWNTO 0);  -- sfix2
          readyout                        :   IN    std_logic;
          readycal                        :   IN    std_logic;
          ce_out                          :   OUT   std_logic;
          outreal                         :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          outimag                         :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          powertop                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
          powerbot                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En33
          drift_FD                        :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En5
          drift_SD                        :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_E11
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : cal_average_instance_C1_fixpt
    USE ENTITY work.cal_average_instance_C1_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL drift_SD_done                    : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL drift_SD_done_enb                : std_logic;  -- ufix1
  SIGNAL outreal_addr                     : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL drift_SD_lastAddr                : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check6_done                      : std_logic;  -- ufix1
  SIGNAL drift_FD_done                    : std_logic;  -- ufix1
  SIGNAL drift_FD_done_enb                : std_logic;  -- ufix1
  SIGNAL drift_FD_lastAddr                : std_logic;  -- ufix1
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL powerbot_done                    : std_logic;  -- ufix1
  SIGNAL powerbot_done_enb                : std_logic;  -- ufix1
  SIGNAL powerbot_lastAddr                : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL powertop_done                    : std_logic;  -- ufix1
  SIGNAL powertop_done_enb                : std_logic;  -- ufix1
  SIGNAL powertop_lastAddr                : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL outimag_done                     : std_logic;  -- ufix1
  SIGNAL outimag_done_enb                 : std_logic;  -- ufix1
  SIGNAL outimag_lastAddr                 : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL outreal_done                     : std_logic;  -- ufix1
  SIGNAL outreal_done_enb                 : std_logic;  -- ufix1
  SIGNAL outreal_active                   : std_logic;  -- ufix1
  SIGNAL real_in_addr                     : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL readycal_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL tb_enb                           : std_logic;
  SIGNAL rawData_readycal                 : std_logic;
  SIGNAL holdData_readycal                : std_logic;
  SIGNAL readycal_offset                  : std_logic;
  SIGNAL readycal                         : std_logic;
  SIGNAL readyout_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_readyout                 : std_logic;
  SIGNAL holdData_readyout                : std_logic;
  SIGNAL readyout_offset                  : std_logic;
  SIGNAL readyout                         : std_logic;
  SIGNAL tick_addr_delay_1                : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_tick                     : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL holdData_tick                    : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL tick_offset                      : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL tick                             : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL tick_1                           : std_logic_vector(1 DOWNTO 0);  -- ufix2
  SIGNAL kar_addr_delay_1                 : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_kar                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL holdData_kar                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL kar_offset                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL kar                              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL kar_1                            : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL phase_cor_addr_delay             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_phase_cor_im             : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL holdData_phase_cor_im            : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_im_offset              : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_im                     : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_im_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL rawData_phase_cor_re             : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL holdData_phase_cor_re            : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_re_offset              : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_re                     : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL phase_cor_re_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL calbin_addr_delay_1              : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_calbin                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL holdData_calbin                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin_offset                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin                           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin_1                         : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL imag_in_addr_delay_1             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_imag_in                  : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL holdData_imag_in                 : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL imag_in_offset                   : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL imag_in                          : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL imag_in_1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL real_in_active                   : std_logic;  -- ufix1
  SIGNAL real_in_enb                      : std_logic;  -- ufix1
  SIGNAL real_in_addr_delay_1             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_real_in                  : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL holdData_real_in                 : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL real_in_offset                   : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL real_in_1                        : signed(31 DOWNTO 0);  -- sfix32_En30
  SIGNAL real_in_2                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL ce_out                           : std_logic;
  SIGNAL outreal                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outimag                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powertop                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powerbot                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_FD                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_SD                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outreal_enb                      : std_logic;  -- ufix1
  SIGNAL outreal_lastAddr                 : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL outreal_signed                   : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal_addr_delay_1             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL outreal_expected                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal_ref                      : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal_testFailure              : std_logic;  -- ufix1
  SIGNAL outimag_signed                   : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag_addr_delay_1             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL outimag_expected                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag_ref                      : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag_testFailure              : std_logic;  -- ufix1
  SIGNAL powertop_unsigned                : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL powertop_expected                : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop_ref                     : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop_testFailure             : std_logic;  -- ufix1
  SIGNAL powerbot_unsigned                : unsigned(31 DOWNTO 0);  -- ufix32_En33
  SIGNAL powerbot_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL powerbot_expected                : unsigned(31 DOWNTO 0);  -- ufix32_En33
  SIGNAL powerbot_ref                     : unsigned(31 DOWNTO 0);  -- ufix32_En33
  SIGNAL powerbot_testFailure             : std_logic;  -- ufix1
  SIGNAL drift_FD_signed                  : signed(31 DOWNTO 0);  -- sfix32_En5
  SIGNAL drift_FD_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL drift_FD_expected                : signed(31 DOWNTO 0);  -- sfix32_En5
  SIGNAL drift_FD_ref                     : signed(31 DOWNTO 0);  -- sfix32_En5
  SIGNAL drift_FD_testFailure             : std_logic;  -- ufix1
  SIGNAL drift_SD_signed                  : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL drift_SD_expected                : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD_ref                     : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD_testFailure             : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_cal_average_instance_C1_fixpt : cal_average_instance_C1_fixpt
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => enb,
              real_in => real_in_2,  -- sfix32_En30
              imag_in => imag_in_1,  -- sfix32_En30
              calbin => calbin_1,  -- ufix10
              phase_cor_re => phase_cor_re_1,  -- sfix32_En30
              phase_cor_im => phase_cor_im_1,  -- sfix32_En30
              kar => kar_1,  -- uint16
              tick => tick_1,  -- sfix2
              readyout => readyout,
              readycal => readycal,
              ce_out => ce_out,
              outreal => outreal,  -- sfix32_En24
              outimag => outimag,  -- sfix32_En24
              powertop => powertop,  -- ufix32_En18
              powerbot => powerbot,  -- ufix32_En33
              drift_FD => drift_FD,  -- sfix32_En5
              drift_SD => drift_SD  -- sfix32_E11
              );

  drift_SD_done_enb <= drift_SD_done AND rdEnb;

  
  drift_SD_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  drift_SD_done <= drift_SD_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_6_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check6_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF drift_SD_done_enb = '1' THEN
        check6_done <= drift_SD_done;
      END IF;
    END IF;
  END PROCESS checkDone_6_process;

  drift_FD_done_enb <= drift_FD_done AND rdEnb;

  
  drift_FD_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  drift_FD_done <= drift_FD_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF drift_FD_done_enb = '1' THEN
        check5_done <= drift_FD_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  powerbot_done_enb <= powerbot_done AND rdEnb;

  
  powerbot_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  powerbot_done <= powerbot_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF powerbot_done_enb = '1' THEN
        check4_done <= powerbot_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  powertop_done_enb <= powertop_done AND rdEnb;

  
  powertop_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  powertop_done <= powertop_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF powertop_done_enb = '1' THEN
        check3_done <= powertop_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  outimag_done_enb <= outimag_done AND rdEnb;

  
  outimag_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  outimag_done <= outimag_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF outimag_done_enb = '1' THEN
        check2_done <= outimag_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  outreal_done_enb <= outreal_done AND rdEnb;

  
  outreal_active <= '1' WHEN outreal_addr /= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  readycal_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for readycal
  readycal_fileread: PROCESS (readycal_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "readycal.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    rawData_readycal <= read_data;
  END PROCESS readycal_fileread;

  -- holdData reg for readycal
  stimuli_readycal_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_readycal <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_readycal <= rawData_readycal;
    END IF;
  END PROCESS stimuli_readycal_process;

  stimuli_readycal_1: PROCESS (rawData_readycal, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      readycal_offset <= holdData_readycal;
    ELSE
      readycal_offset <= rawData_readycal;
    END IF;
  END PROCESS stimuli_readycal_1;

  readycal <= readycal_offset AFTER 2 ns;

  readyout_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for readyout
  readyout_fileread: PROCESS (readyout_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "readyout.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    rawData_readyout <= read_data;
  END PROCESS readyout_fileread;

  -- holdData reg for readyout
  stimuli_readyout_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_readyout <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_readyout <= rawData_readyout;
    END IF;
  END PROCESS stimuli_readyout_process;

  stimuli_readyout_1: PROCESS (rawData_readyout, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      readyout_offset <= holdData_readyout;
    ELSE
      readyout_offset <= rawData_readyout;
    END IF;
  END PROCESS stimuli_readyout_1;

  readyout <= readyout_offset AFTER 2 ns;

  tick_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for tick
  tick_fileread: PROCESS (tick_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "tick.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(3 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_tick <= signed(read_data(1 DOWNTO 0));
  END PROCESS tick_fileread;

  -- holdData reg for tick
  stimuli_tick_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_tick <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_tick <= rawData_tick;
    END IF;
  END PROCESS stimuli_tick_process;

  stimuli_tick_1: PROCESS (rawData_tick, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      tick_offset <= holdData_tick;
    ELSE
      tick_offset <= rawData_tick;
    END IF;
  END PROCESS stimuli_tick_1;

  tick <= tick_offset AFTER 2 ns;

  tick_1 <= std_logic_vector(tick);

  kar_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for kar
  kar_fileread: PROCESS (kar_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "kar.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_kar <= unsigned(read_data(15 DOWNTO 0));
  END PROCESS kar_fileread;

  -- holdData reg for kar
  stimuli_kar_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_kar <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_kar <= rawData_kar;
    END IF;
  END PROCESS stimuli_kar_process;

  stimuli_kar_1: PROCESS (rawData_kar, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      kar_offset <= holdData_kar;
    ELSE
      kar_offset <= rawData_kar;
    END IF;
  END PROCESS stimuli_kar_1;

  kar <= kar_offset AFTER 2 ns;

  kar_1 <= std_logic_vector(kar);

  -- Data source for phase_cor_im
  phase_cor_im_fileread: PROCESS (phase_cor_addr_delay, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "phase_cor_im.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_phase_cor_im <= signed(read_data(31 DOWNTO 0));
  END PROCESS phase_cor_im_fileread;

  -- holdData reg for phase_cor
  stimuli_phase_cor_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_phase_cor_im <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_phase_cor_im <= rawData_phase_cor_im;
    END IF;
  END PROCESS stimuli_phase_cor_process;

  stimuli_phase_cor_1: PROCESS (rawData_phase_cor_im, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      phase_cor_im_offset <= holdData_phase_cor_im;
    ELSE
      phase_cor_im_offset <= rawData_phase_cor_im;
    END IF;
  END PROCESS stimuli_phase_cor_1;

  phase_cor_im <= phase_cor_im_offset AFTER 2 ns;

  phase_cor_im_1 <= std_logic_vector(phase_cor_im);

  phase_cor_addr_delay <= real_in_addr AFTER 1 ns;

  -- Data source for phase_cor_re
  phase_cor_re_fileread: PROCESS (phase_cor_addr_delay, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "phase_cor_re.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_phase_cor_re <= signed(read_data(31 DOWNTO 0));
  END PROCESS phase_cor_re_fileread;

  -- holdData reg for phase_cor
  stimuli_phase_cor_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_phase_cor_re <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_phase_cor_re <= rawData_phase_cor_re;
    END IF;
  END PROCESS stimuli_phase_cor_2_process;

  stimuli_phase_cor_3: PROCESS (rawData_phase_cor_re, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      phase_cor_re_offset <= holdData_phase_cor_re;
    ELSE
      phase_cor_re_offset <= rawData_phase_cor_re;
    END IF;
  END PROCESS stimuli_phase_cor_3;

  phase_cor_re <= phase_cor_re_offset AFTER 2 ns;

  phase_cor_re_1 <= std_logic_vector(phase_cor_re);

  calbin_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for calbin
  calbin_fileread: PROCESS (calbin_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "calbin.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(11 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_calbin <= unsigned(read_data(9 DOWNTO 0));
  END PROCESS calbin_fileread;

  -- holdData reg for calbin
  stimuli_calbin_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_calbin <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_calbin <= rawData_calbin;
    END IF;
  END PROCESS stimuli_calbin_process;

  stimuli_calbin_1: PROCESS (rawData_calbin, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      calbin_offset <= holdData_calbin;
    ELSE
      calbin_offset <= rawData_calbin;
    END IF;
  END PROCESS stimuli_calbin_1;

  calbin <= calbin_offset AFTER 2 ns;

  calbin_1 <= std_logic_vector(calbin);

  imag_in_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for imag_in
  imag_in_fileread: PROCESS (imag_in_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "imag_in.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_imag_in <= signed(read_data(31 DOWNTO 0));
  END PROCESS imag_in_fileread;

  -- holdData reg for imag_in
  stimuli_imag_in_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_imag_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_imag_in <= rawData_imag_in;
    END IF;
  END PROCESS stimuli_imag_in_process;

  stimuli_imag_in_1: PROCESS (rawData_imag_in, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      imag_in_offset <= holdData_imag_in;
    ELSE
      imag_in_offset <= rawData_imag_in;
    END IF;
  END PROCESS stimuli_imag_in_1;

  imag_in <= imag_in_offset AFTER 2 ns;

  imag_in_1 <= std_logic_vector(imag_in);

  
  real_in_active <= '1' WHEN real_in_addr /= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  real_in_enb <= real_in_active AND (rdEnb AND tb_enb);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13107199
  real_in_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      real_in_addr <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF real_in_enb = '1' THEN
        IF real_in_addr >= to_unsigned(16#C7FFFF#, 24) THEN 
          real_in_addr <= to_unsigned(16#000000#, 24);
        ELSE 
          real_in_addr <= real_in_addr + to_unsigned(16#000001#, 24);
        END IF;
      END IF;
    END IF;
  END PROCESS real_in_process;


  real_in_addr_delay_1 <= real_in_addr AFTER 1 ns;

  -- Data source for real_in
  real_in_fileread: PROCESS (real_in_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "real_in.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_real_in <= signed(read_data(31 DOWNTO 0));
  END PROCESS real_in_fileread;

  -- holdData reg for real_in
  stimuli_real_in_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_real_in <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_real_in <= rawData_real_in;
    END IF;
  END PROCESS stimuli_real_in_process;

  stimuli_real_in_1: PROCESS (rawData_real_in, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      real_in_offset <= holdData_real_in;
    ELSE
      real_in_offset <= rawData_real_in;
    END IF;
  END PROCESS stimuli_real_in_1;

  real_in_1 <= real_in_offset AFTER 2 ns;

  real_in_2 <= std_logic_vector(real_in_1);

  snkDonen <=  NOT snkDone;

  resetn <=  NOT reset;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  enb <= rdEnb AFTER 2 ns;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  outreal_enb <= ce_out AND outreal_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13107199
  outreal_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outreal_addr <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF outreal_enb = '1' THEN
        IF outreal_addr >= to_unsigned(16#C7FFFF#, 24) THEN 
          outreal_addr <= to_unsigned(16#000000#, 24);
        ELSE 
          outreal_addr <= outreal_addr + to_unsigned(16#000001#, 24);
        END IF;
      END IF;
    END IF;
  END PROCESS outreal_1_process;


  
  outreal_lastAddr <= '1' WHEN outreal_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  outreal_done <= outreal_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF outreal_done_enb = '1' THEN
        check1_done <= outreal_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check6_done AND (check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done))));

  outreal_signed <= signed(outreal);

  outreal_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for outreal_expected
  outreal_expected_fileread: PROCESS (outreal_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "outreal_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    outreal_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS outreal_expected_fileread;

  outreal_ref <= outreal_expected;

  outreal_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outreal_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND outreal_signed /= outreal_ref THEN
        outreal_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in outreal_signed: Expected " & to_hex(outreal_ref) & (" Actual " & to_hex(outreal_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS outreal_signed_checker;

  outimag_signed <= signed(outimag);

  outimag_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for outimag_expected
  outimag_expected_fileread: PROCESS (outimag_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "outimag_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    outimag_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS outimag_expected_fileread;

  outimag_ref <= outimag_expected;

  outimag_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outimag_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND outimag_signed /= outimag_ref THEN
        outimag_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in outimag_signed: Expected " & to_hex(outimag_ref) & (" Actual " & to_hex(outimag_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS outimag_signed_checker;

  powertop_unsigned <= unsigned(powertop);

  powertop_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for powertop_expected
  powertop_expected_fileread: PROCESS (powertop_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "powertop_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    powertop_expected <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powertop_expected_fileread;

  powertop_ref <= powertop_expected;

  powertop_unsigned_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      powertop_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND powertop_unsigned /= powertop_ref THEN
        powertop_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in powertop_unsigned: Expected " & to_hex(powertop_ref) & (" Actual " & to_hex(powertop_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS powertop_unsigned_checker;

  powerbot_unsigned <= unsigned(powerbot);

  powerbot_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for powerbot_expected
  powerbot_expected_fileread: PROCESS (powerbot_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "powerbot_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    powerbot_expected <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powerbot_expected_fileread;

  powerbot_ref <= powerbot_expected;

  powerbot_unsigned_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      powerbot_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND powerbot_unsigned /= powerbot_ref THEN
        powerbot_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in powerbot_unsigned: Expected " & to_hex(powerbot_ref) & (" Actual " & to_hex(powerbot_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS powerbot_unsigned_checker;

  drift_FD_signed <= signed(drift_FD);

  drift_FD_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for drift_FD_expected
  drift_FD_expected_fileread: PROCESS (drift_FD_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "drift_FD_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    drift_FD_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_FD_expected_fileread;

  drift_FD_ref <= drift_FD_expected;

  drift_FD_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      drift_FD_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND drift_FD_signed /= drift_FD_ref THEN
        drift_FD_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in drift_FD_signed: Expected " & to_hex(drift_FD_ref) & (" Actual " & to_hex(drift_FD_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS drift_FD_signed_checker;

  drift_SD_signed <= signed(drift_SD);

  drift_SD_addr_delay_1 <= outreal_addr AFTER 1 ns;

  -- Data source for drift_SD_expected
  drift_SD_expected_fileread: PROCESS (drift_SD_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "drift_SD_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    drift_SD_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_SD_expected_fileread;

  drift_SD_ref <= drift_SD_expected;

  drift_SD_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      drift_SD_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND drift_SD_signed /= drift_SD_ref THEN
        drift_SD_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in drift_SD_signed: Expected " & to_hex(drift_SD_ref) & (" Actual " & to_hex(drift_SD_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS drift_SD_signed_checker;

  testFailure <= drift_SD_testFailure OR (drift_FD_testFailure OR (powerbot_testFailure OR (powertop_testFailure OR (outreal_testFailure OR outimag_testFailure))));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

