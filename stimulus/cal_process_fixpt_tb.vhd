-- -------------------------------------------------------------
-- 
-- File Name: /u/home/eraguzin/matlab/LNspec/matlab/codegen/cal_process/hdlsrc/cal_process_fixpt_tb.vhd
-- Created: 2024-01-11 13:05:48
-- 
-- Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- drift                         ce_out        1
-- have_lock_out                 ce_out        1
-- foutreal1                     ce_out        1
-- foutimag1                     ce_out        1
-- foutreal2                     ce_out        1
-- foutimag2                     ce_out        1
-- foutreal3                     ce_out        1
-- foutimag3                     ce_out        1
-- foutreal4                     ce_out        1
-- foutimag4                     ce_out        1
-- fout_ready                    ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: cal_process_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.cal_process_fixpt_pkg.ALL;
USE work.cal_process_fixpt_tb_pkg.ALL;

ENTITY cal_process_fixpt_tb IS
END cal_process_fixpt_tb;


ARCHITECTURE rtl OF cal_process_fixpt_tb IS

  -- Component Declarations
  COMPONENT cal_process_fixpt
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          outreal1                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          outimag1                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          powertop1                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
          powerbot1                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          drift_FD1                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En4
          drift_SD1                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_E11
          outreal2                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En25
          outimag2                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En25
          powertop2                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En21
          powerbot2                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En21
          drift_FD2                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En7
          drift_SD2                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_E8
          outreal3                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          outimag3                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          powertop3                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En18
          powerbot3                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          drift_FD3                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En4
          drift_SD3                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_E11
          outreal4                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En25
          outimag4                        :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En25
          powertop4                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En21
          powerbot4                       :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En21
          drift_FD4                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En7
          drift_SD4                       :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_E8
          calbin                          :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          readyout                        :   IN    std_logic;
          drift_1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En43
          update_drift                    :   IN    std_logic;
          ce_out                          :   OUT   std_logic;
          drift                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En43
          have_lock_out                   :   OUT   std_logic;
          foutreal1                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
          foutimag1                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
          foutreal2                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          foutimag2                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          foutreal3                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
          foutimag3                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
          foutreal4                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          foutimag4                       :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En24
          fout_ready                      :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : cal_process_fixpt
    USE ENTITY work.cal_process_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL fout_ready_done                  : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL fout_ready_done_enb              : std_logic;  -- ufix1
  SIGNAL drift_addr                       : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL fout_ready_lastAddr              : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check11_done                     : std_logic;  -- ufix1
  SIGNAL foutimag4_done                   : std_logic;  -- ufix1
  SIGNAL foutimag4_done_enb               : std_logic;  -- ufix1
  SIGNAL foutimag4_lastAddr               : std_logic;  -- ufix1
  SIGNAL check10_done                     : std_logic;  -- ufix1
  SIGNAL foutreal4_done                   : std_logic;  -- ufix1
  SIGNAL foutreal4_done_enb               : std_logic;  -- ufix1
  SIGNAL foutreal4_lastAddr               : std_logic;  -- ufix1
  SIGNAL check9_done                      : std_logic;  -- ufix1
  SIGNAL foutimag3_done                   : std_logic;  -- ufix1
  SIGNAL foutimag3_done_enb               : std_logic;  -- ufix1
  SIGNAL foutimag3_lastAddr               : std_logic;  -- ufix1
  SIGNAL check8_done                      : std_logic;  -- ufix1
  SIGNAL foutreal3_done                   : std_logic;  -- ufix1
  SIGNAL foutreal3_done_enb               : std_logic;  -- ufix1
  SIGNAL foutreal3_lastAddr               : std_logic;  -- ufix1
  SIGNAL check7_done                      : std_logic;  -- ufix1
  SIGNAL foutimag2_done                   : std_logic;  -- ufix1
  SIGNAL foutimag2_done_enb               : std_logic;  -- ufix1
  SIGNAL foutimag2_lastAddr               : std_logic;  -- ufix1
  SIGNAL check6_done                      : std_logic;  -- ufix1
  SIGNAL foutreal2_done                   : std_logic;  -- ufix1
  SIGNAL foutreal2_done_enb               : std_logic;  -- ufix1
  SIGNAL foutreal2_lastAddr               : std_logic;  -- ufix1
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL foutimag1_done                   : std_logic;  -- ufix1
  SIGNAL foutimag1_done_enb               : std_logic;  -- ufix1
  SIGNAL foutimag1_lastAddr               : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL foutreal1_done                   : std_logic;  -- ufix1
  SIGNAL foutreal1_done_enb               : std_logic;  -- ufix1
  SIGNAL foutreal1_lastAddr               : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL have_lock_out_done               : std_logic;  -- ufix1
  SIGNAL have_lock_out_done_enb           : std_logic;  -- ufix1
  SIGNAL have_lock_out_lastAddr           : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL drift_done                       : std_logic;  -- ufix1
  SIGNAL drift_done_enb                   : std_logic;  -- ufix1
  SIGNAL drift_active                     : std_logic;  -- ufix1
  SIGNAL outreal1_addr                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL update_drift_addr_delay_1        : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL tb_enb                           : std_logic;
  SIGNAL rawData_update_drift             : std_logic;
  SIGNAL holdData_update_drift            : std_logic;
  SIGNAL update_drift_offset              : std_logic;
  SIGNAL update_drift                     : std_logic;
  SIGNAL drift_1_addr_delay_1             : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_1                  : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL holdData_drift_1                 : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_1_offset                   : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_1                          : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_1_1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL readyout_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_readyout                 : std_logic;
  SIGNAL holdData_readyout                : std_logic;
  SIGNAL readyout_offset                  : std_logic;
  SIGNAL readyout                         : std_logic;
  SIGNAL calbin_addr_delay_1              : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_calbin                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL holdData_calbin                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin_offset                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin                           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL calbin_1                         : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL drift_SD4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_SD4                : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL holdData_drift_SD4               : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD4_offset                 : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD4                        : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD4_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_FD4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_FD4                : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL holdData_drift_FD4               : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD4_offset                 : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD4                        : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD4_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powerbot4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powerbot4                : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL holdData_powerbot4               : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot4_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot4                        : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot4_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powertop4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powertop4                : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL holdData_powertop4               : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop4_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop4                        : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop4_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outimag4_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outimag4                 : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL holdData_outimag4                : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag4_offset                  : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag4                         : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag4_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outreal4_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outreal4                 : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL holdData_outreal4                : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal4_offset                  : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal4                         : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal4_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_SD3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_SD3                : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL holdData_drift_SD3               : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD3_offset                 : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD3                        : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD3_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_FD3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_FD3                : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL holdData_drift_FD3               : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD3_offset                 : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD3                        : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD3_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powerbot3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powerbot3                : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL holdData_powerbot3               : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot3_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot3                        : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot3_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powertop3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powertop3                : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL holdData_powertop3               : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop3_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop3                        : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop3_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outimag3_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outimag3                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL holdData_outimag3                : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag3_offset                  : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag3                         : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag3_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outreal3_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outreal3                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL holdData_outreal3                : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal3_offset                  : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal3                         : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal3_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_SD2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_SD2                : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL holdData_drift_SD2               : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD2_offset                 : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD2                        : signed(31 DOWNTO 0);  -- sfix32_E8
  SIGNAL drift_SD2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_FD2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_FD2                : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL holdData_drift_FD2               : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD2_offset                 : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD2                        : signed(31 DOWNTO 0);  -- sfix32_En7
  SIGNAL drift_FD2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powerbot2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powerbot2                : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL holdData_powerbot2               : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot2_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot2                        : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powerbot2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powertop2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powertop2                : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL holdData_powertop2               : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop2_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop2                        : unsigned(31 DOWNTO 0);  -- ufix32_En21
  SIGNAL powertop2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outimag2_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outimag2                 : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL holdData_outimag2                : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag2_offset                  : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag2                         : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outimag2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outreal2_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outreal2                 : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL holdData_outreal2                : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal2_offset                  : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal2                         : signed(31 DOWNTO 0);  -- sfix32_En25
  SIGNAL outreal2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_SD1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_SD1                : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL holdData_drift_SD1               : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD1_offset                 : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD1                        : signed(31 DOWNTO 0);  -- sfix32_E11
  SIGNAL drift_SD1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL drift_FD1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_drift_FD1                : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL holdData_drift_FD1               : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD1_offset                 : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD1                        : signed(31 DOWNTO 0);  -- sfix32_En4
  SIGNAL drift_FD1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powerbot1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powerbot1                : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL holdData_powerbot1               : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot1_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot1                        : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL powerbot1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL powertop1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_powertop1                : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL holdData_powertop1               : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop1_offset                 : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop1                        : unsigned(31 DOWNTO 0);  -- ufix32_En18
  SIGNAL powertop1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outimag1_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outimag1                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL holdData_outimag1                : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag1_offset                  : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag1                         : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outimag1_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL outreal1_active                  : std_logic;  -- ufix1
  SIGNAL outreal1_enb                     : std_logic;  -- ufix1
  SIGNAL outreal1_addr_delay_1            : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL rawData_outreal1                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL holdData_outreal1                : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal1_offset                  : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal1_1                       : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL outreal1_2                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL ce_out                           : std_logic;
  SIGNAL drift                            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL have_lock_out                    : std_logic;
  SIGNAL foutreal1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutimag1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutreal2                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutimag2                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutreal3                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutimag3                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutreal4                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL foutimag4                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL fout_ready                       : std_logic;
  SIGNAL drift_enb                        : std_logic;  -- ufix1
  SIGNAL drift_lastAddr                   : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL drift_signed                     : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_addr_delay_1               : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL drift_expected                   : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_ref                        : signed(31 DOWNTO 0);  -- sfix32_En43
  SIGNAL drift_testFailure                : std_logic;  -- ufix1
  SIGNAL have_lock_out_addr_delay_1       : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL have_lock_out_expected           : std_logic;
  SIGNAL have_lock_out_ref                : std_logic;
  SIGNAL have_lock_out_testFailure        : std_logic;  -- ufix1
  SIGNAL foutreal1_signed                 : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutreal1_expected               : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal1_ref                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal1_testFailure            : std_logic;  -- ufix1
  SIGNAL foutimag1_signed                 : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag1_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutimag1_expected               : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag1_ref                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag1_testFailure            : std_logic;  -- ufix1
  SIGNAL foutreal2_signed                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutreal2_expected               : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal2_ref                    : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal2_testFailure            : std_logic;  -- ufix1
  SIGNAL foutimag2_signed                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag2_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutimag2_expected               : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag2_ref                    : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag2_testFailure            : std_logic;  -- ufix1
  SIGNAL foutreal3_signed                 : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutreal3_expected               : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal3_ref                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutreal3_testFailure            : std_logic;  -- ufix1
  SIGNAL foutimag3_signed                 : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag3_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutimag3_expected               : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag3_ref                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL foutimag3_testFailure            : std_logic;  -- ufix1
  SIGNAL foutreal4_signed                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutreal4_expected               : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal4_ref                    : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutreal4_testFailure            : std_logic;  -- ufix1
  SIGNAL foutimag4_signed                 : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag4_addr_delay_1           : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL foutimag4_expected               : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag4_ref                    : signed(31 DOWNTO 0);  -- sfix32_En24
  SIGNAL foutimag4_testFailure            : std_logic;  -- ufix1
  SIGNAL fout_ready_addr_delay_1          : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL fout_ready_expected              : std_logic;
  SIGNAL fout_ready_ref                   : std_logic;
  SIGNAL fout_ready_testFailure           : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_cal_process_fixpt : cal_process_fixpt
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => enb,
              outreal1 => outreal1_2,  -- sfix32_En24
              outimag1 => outimag1_1,  -- sfix32_En24
              powertop1 => powertop1_1,  -- ufix32_En18
              powerbot1 => powerbot1_1,  -- ufix32_En30
              drift_FD1 => drift_FD1_1,  -- sfix32_En4
              drift_SD1 => drift_SD1_1,  -- sfix32_E11
              outreal2 => outreal2_1,  -- sfix32_En25
              outimag2 => outimag2_1,  -- sfix32_En25
              powertop2 => powertop2_1,  -- ufix32_En21
              powerbot2 => powerbot2_1,  -- ufix32_En21
              drift_FD2 => drift_FD2_1,  -- sfix32_En7
              drift_SD2 => drift_SD2_1,  -- sfix32_E8
              outreal3 => outreal3_1,  -- sfix32_En24
              outimag3 => outimag3_1,  -- sfix32_En24
              powertop3 => powertop3_1,  -- ufix32_En18
              powerbot3 => powerbot3_1,  -- ufix32_En30
              drift_FD3 => drift_FD3_1,  -- sfix32_En4
              drift_SD3 => drift_SD3_1,  -- sfix32_E11
              outreal4 => outreal4_1,  -- sfix32_En25
              outimag4 => outimag4_1,  -- sfix32_En25
              powertop4 => powertop4_1,  -- ufix32_En21
              powerbot4 => powerbot4_1,  -- ufix32_En21
              drift_FD4 => drift_FD4_1,  -- sfix32_En7
              drift_SD4 => drift_SD4_1,  -- sfix32_E8
              calbin => calbin_1,  -- ufix10
              readyout => readyout,
              drift_1 => drift_1_1,  -- sfix32_En43
              update_drift => update_drift,
              ce_out => ce_out,
              drift => drift,  -- sfix32_En43
              have_lock_out => have_lock_out,
              foutreal1 => foutreal1,  -- sfix32_En20
              foutimag1 => foutimag1,  -- sfix32_En20
              foutreal2 => foutreal2,  -- sfix32_En24
              foutimag2 => foutimag2,  -- sfix32_En24
              foutreal3 => foutreal3,  -- sfix32_En20
              foutimag3 => foutimag3,  -- sfix32_En20
              foutreal4 => foutreal4,  -- sfix32_En24
              foutimag4 => foutimag4,  -- sfix32_En24
              fout_ready => fout_ready
              );

  fout_ready_done_enb <= fout_ready_done AND rdEnb;

  
  fout_ready_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  fout_ready_done <= fout_ready_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_11_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check11_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF fout_ready_done_enb = '1' THEN
        check11_done <= fout_ready_done;
      END IF;
    END IF;
  END PROCESS checkDone_11_process;

  foutimag4_done_enb <= foutimag4_done AND rdEnb;

  
  foutimag4_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutimag4_done <= foutimag4_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_10_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check10_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutimag4_done_enb = '1' THEN
        check10_done <= foutimag4_done;
      END IF;
    END IF;
  END PROCESS checkDone_10_process;

  foutreal4_done_enb <= foutreal4_done AND rdEnb;

  
  foutreal4_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutreal4_done <= foutreal4_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_9_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check9_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutreal4_done_enb = '1' THEN
        check9_done <= foutreal4_done;
      END IF;
    END IF;
  END PROCESS checkDone_9_process;

  foutimag3_done_enb <= foutimag3_done AND rdEnb;

  
  foutimag3_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutimag3_done <= foutimag3_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_8_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check8_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutimag3_done_enb = '1' THEN
        check8_done <= foutimag3_done;
      END IF;
    END IF;
  END PROCESS checkDone_8_process;

  foutreal3_done_enb <= foutreal3_done AND rdEnb;

  
  foutreal3_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutreal3_done <= foutreal3_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_7_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check7_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutreal3_done_enb = '1' THEN
        check7_done <= foutreal3_done;
      END IF;
    END IF;
  END PROCESS checkDone_7_process;

  foutimag2_done_enb <= foutimag2_done AND rdEnb;

  
  foutimag2_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutimag2_done <= foutimag2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_6_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check6_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutimag2_done_enb = '1' THEN
        check6_done <= foutimag2_done;
      END IF;
    END IF;
  END PROCESS checkDone_6_process;

  foutreal2_done_enb <= foutreal2_done AND rdEnb;

  
  foutreal2_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutreal2_done <= foutreal2_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check5_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutreal2_done_enb = '1' THEN
        check5_done <= foutreal2_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  foutimag1_done_enb <= foutimag1_done AND rdEnb;

  
  foutimag1_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutimag1_done <= foutimag1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check4_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutimag1_done_enb = '1' THEN
        check4_done <= foutimag1_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  foutreal1_done_enb <= foutreal1_done AND rdEnb;

  
  foutreal1_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  foutreal1_done <= foutreal1_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check3_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF foutreal1_done_enb = '1' THEN
        check3_done <= foutreal1_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  have_lock_out_done_enb <= have_lock_out_done AND rdEnb;

  
  have_lock_out_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  have_lock_out_done <= have_lock_out_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF have_lock_out_done_enb = '1' THEN
        check2_done <= have_lock_out_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  drift_done_enb <= drift_done AND rdEnb;

  
  drift_active <= '1' WHEN drift_addr /= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  update_drift_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for update_drift
  update_drift_fileread: PROCESS (update_drift_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "update_drift.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    rawData_update_drift <= read_data;
  END PROCESS update_drift_fileread;

  -- holdData reg for update_drift
  stimuli_update_drift_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_update_drift <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_update_drift <= rawData_update_drift;
    END IF;
  END PROCESS stimuli_update_drift_process;

  stimuli_update_drift_1: PROCESS (rawData_update_drift, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      update_drift_offset <= holdData_update_drift;
    ELSE
      update_drift_offset <= rawData_update_drift;
    END IF;
  END PROCESS stimuli_update_drift_1;

  update_drift <= update_drift_offset AFTER 2 ns;

  drift_1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_1
  drift_1_fileread: PROCESS (drift_1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_1 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_1_fileread;

  -- holdData reg for drift_1
  stimuli_drift_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_1 <= rawData_drift_1;
    END IF;
  END PROCESS stimuli_drift_1_process;

  stimuli_drift_1_1: PROCESS (rawData_drift_1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_1_offset <= holdData_drift_1;
    ELSE
      drift_1_offset <= rawData_drift_1;
    END IF;
  END PROCESS stimuli_drift_1_1;

  drift_1 <= drift_1_offset AFTER 2 ns;

  drift_1_1 <= std_logic_vector(drift_1);

  readyout_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for readyout
  readyout_fileread: PROCESS (readyout_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "readyout.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    rawData_readyout <= read_data;
  END PROCESS readyout_fileread;

  -- holdData reg for readyout
  stimuli_readyout_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_readyout <= 'X';
    ELSIF clk'event AND clk = '1' THEN
      holdData_readyout <= rawData_readyout;
    END IF;
  END PROCESS stimuli_readyout_process;

  stimuli_readyout_1: PROCESS (rawData_readyout, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      readyout_offset <= holdData_readyout;
    ELSE
      readyout_offset <= rawData_readyout;
    END IF;
  END PROCESS stimuli_readyout_1;

  readyout <= readyout_offset AFTER 2 ns;

  calbin_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for calbin
  calbin_fileread: PROCESS (calbin_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "calbin.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(11 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_calbin <= unsigned(read_data(9 DOWNTO 0));
  END PROCESS calbin_fileread;

  -- holdData reg for calbin
  stimuli_calbin_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_calbin <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_calbin <= rawData_calbin;
    END IF;
  END PROCESS stimuli_calbin_process;

  stimuli_calbin_1: PROCESS (rawData_calbin, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      calbin_offset <= holdData_calbin;
    ELSE
      calbin_offset <= rawData_calbin;
    END IF;
  END PROCESS stimuli_calbin_1;

  calbin <= calbin_offset AFTER 2 ns;

  calbin_1 <= std_logic_vector(calbin);

  drift_SD4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_SD4
  drift_SD4_fileread: PROCESS (drift_SD4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_SD4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_SD4 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_SD4_fileread;

  -- holdData reg for drift_SD4
  stimuli_drift_SD4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_SD4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_SD4 <= rawData_drift_SD4;
    END IF;
  END PROCESS stimuli_drift_SD4_process;

  stimuli_drift_SD4_1: PROCESS (rawData_drift_SD4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_SD4_offset <= holdData_drift_SD4;
    ELSE
      drift_SD4_offset <= rawData_drift_SD4;
    END IF;
  END PROCESS stimuli_drift_SD4_1;

  drift_SD4 <= drift_SD4_offset AFTER 2 ns;

  drift_SD4_1 <= std_logic_vector(drift_SD4);

  drift_FD4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_FD4
  drift_FD4_fileread: PROCESS (drift_FD4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_FD4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_FD4 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_FD4_fileread;

  -- holdData reg for drift_FD4
  stimuli_drift_FD4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_FD4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_FD4 <= rawData_drift_FD4;
    END IF;
  END PROCESS stimuli_drift_FD4_process;

  stimuli_drift_FD4_1: PROCESS (rawData_drift_FD4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_FD4_offset <= holdData_drift_FD4;
    ELSE
      drift_FD4_offset <= rawData_drift_FD4;
    END IF;
  END PROCESS stimuli_drift_FD4_1;

  drift_FD4 <= drift_FD4_offset AFTER 2 ns;

  drift_FD4_1 <= std_logic_vector(drift_FD4);

  powerbot4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powerbot4
  powerbot4_fileread: PROCESS (powerbot4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powerbot4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powerbot4 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powerbot4_fileread;

  -- holdData reg for powerbot4
  stimuli_powerbot4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powerbot4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powerbot4 <= rawData_powerbot4;
    END IF;
  END PROCESS stimuli_powerbot4_process;

  stimuli_powerbot4_1: PROCESS (rawData_powerbot4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powerbot4_offset <= holdData_powerbot4;
    ELSE
      powerbot4_offset <= rawData_powerbot4;
    END IF;
  END PROCESS stimuli_powerbot4_1;

  powerbot4 <= powerbot4_offset AFTER 2 ns;

  powerbot4_1 <= std_logic_vector(powerbot4);

  powertop4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powertop4
  powertop4_fileread: PROCESS (powertop4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powertop4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powertop4 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powertop4_fileread;

  -- holdData reg for powertop4
  stimuli_powertop4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powertop4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powertop4 <= rawData_powertop4;
    END IF;
  END PROCESS stimuli_powertop4_process;

  stimuli_powertop4_1: PROCESS (rawData_powertop4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powertop4_offset <= holdData_powertop4;
    ELSE
      powertop4_offset <= rawData_powertop4;
    END IF;
  END PROCESS stimuli_powertop4_1;

  powertop4 <= powertop4_offset AFTER 2 ns;

  powertop4_1 <= std_logic_vector(powertop4);

  outimag4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outimag4
  outimag4_fileread: PROCESS (outimag4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outimag4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outimag4 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outimag4_fileread;

  -- holdData reg for outimag4
  stimuli_outimag4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outimag4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outimag4 <= rawData_outimag4;
    END IF;
  END PROCESS stimuli_outimag4_process;

  stimuli_outimag4_1: PROCESS (rawData_outimag4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outimag4_offset <= holdData_outimag4;
    ELSE
      outimag4_offset <= rawData_outimag4;
    END IF;
  END PROCESS stimuli_outimag4_1;

  outimag4 <= outimag4_offset AFTER 2 ns;

  outimag4_1 <= std_logic_vector(outimag4);

  outreal4_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outreal4
  outreal4_fileread: PROCESS (outreal4_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outreal4.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outreal4 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outreal4_fileread;

  -- holdData reg for outreal4
  stimuli_outreal4_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outreal4 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outreal4 <= rawData_outreal4;
    END IF;
  END PROCESS stimuli_outreal4_process;

  stimuli_outreal4_1: PROCESS (rawData_outreal4, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outreal4_offset <= holdData_outreal4;
    ELSE
      outreal4_offset <= rawData_outreal4;
    END IF;
  END PROCESS stimuli_outreal4_1;

  outreal4 <= outreal4_offset AFTER 2 ns;

  outreal4_1 <= std_logic_vector(outreal4);

  drift_SD3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_SD3
  drift_SD3_fileread: PROCESS (drift_SD3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_SD3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_SD3 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_SD3_fileread;

  -- holdData reg for drift_SD3
  stimuli_drift_SD3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_SD3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_SD3 <= rawData_drift_SD3;
    END IF;
  END PROCESS stimuli_drift_SD3_process;

  stimuli_drift_SD3_1: PROCESS (rawData_drift_SD3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_SD3_offset <= holdData_drift_SD3;
    ELSE
      drift_SD3_offset <= rawData_drift_SD3;
    END IF;
  END PROCESS stimuli_drift_SD3_1;

  drift_SD3 <= drift_SD3_offset AFTER 2 ns;

  drift_SD3_1 <= std_logic_vector(drift_SD3);

  drift_FD3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_FD3
  drift_FD3_fileread: PROCESS (drift_FD3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_FD3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_FD3 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_FD3_fileread;

  -- holdData reg for drift_FD3
  stimuli_drift_FD3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_FD3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_FD3 <= rawData_drift_FD3;
    END IF;
  END PROCESS stimuli_drift_FD3_process;

  stimuli_drift_FD3_1: PROCESS (rawData_drift_FD3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_FD3_offset <= holdData_drift_FD3;
    ELSE
      drift_FD3_offset <= rawData_drift_FD3;
    END IF;
  END PROCESS stimuli_drift_FD3_1;

  drift_FD3 <= drift_FD3_offset AFTER 2 ns;

  drift_FD3_1 <= std_logic_vector(drift_FD3);

  powerbot3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powerbot3
  powerbot3_fileread: PROCESS (powerbot3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powerbot3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powerbot3 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powerbot3_fileread;

  -- holdData reg for powerbot3
  stimuli_powerbot3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powerbot3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powerbot3 <= rawData_powerbot3;
    END IF;
  END PROCESS stimuli_powerbot3_process;

  stimuli_powerbot3_1: PROCESS (rawData_powerbot3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powerbot3_offset <= holdData_powerbot3;
    ELSE
      powerbot3_offset <= rawData_powerbot3;
    END IF;
  END PROCESS stimuli_powerbot3_1;

  powerbot3 <= powerbot3_offset AFTER 2 ns;

  powerbot3_1 <= std_logic_vector(powerbot3);

  powertop3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powertop3
  powertop3_fileread: PROCESS (powertop3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powertop3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powertop3 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powertop3_fileread;

  -- holdData reg for powertop3
  stimuli_powertop3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powertop3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powertop3 <= rawData_powertop3;
    END IF;
  END PROCESS stimuli_powertop3_process;

  stimuli_powertop3_1: PROCESS (rawData_powertop3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powertop3_offset <= holdData_powertop3;
    ELSE
      powertop3_offset <= rawData_powertop3;
    END IF;
  END PROCESS stimuli_powertop3_1;

  powertop3 <= powertop3_offset AFTER 2 ns;

  powertop3_1 <= std_logic_vector(powertop3);

  outimag3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outimag3
  outimag3_fileread: PROCESS (outimag3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outimag3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outimag3 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outimag3_fileread;

  -- holdData reg for outimag3
  stimuli_outimag3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outimag3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outimag3 <= rawData_outimag3;
    END IF;
  END PROCESS stimuli_outimag3_process;

  stimuli_outimag3_1: PROCESS (rawData_outimag3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outimag3_offset <= holdData_outimag3;
    ELSE
      outimag3_offset <= rawData_outimag3;
    END IF;
  END PROCESS stimuli_outimag3_1;

  outimag3 <= outimag3_offset AFTER 2 ns;

  outimag3_1 <= std_logic_vector(outimag3);

  outreal3_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outreal3
  outreal3_fileread: PROCESS (outreal3_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outreal3.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outreal3 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outreal3_fileread;

  -- holdData reg for outreal3
  stimuli_outreal3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outreal3 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outreal3 <= rawData_outreal3;
    END IF;
  END PROCESS stimuli_outreal3_process;

  stimuli_outreal3_1: PROCESS (rawData_outreal3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outreal3_offset <= holdData_outreal3;
    ELSE
      outreal3_offset <= rawData_outreal3;
    END IF;
  END PROCESS stimuli_outreal3_1;

  outreal3 <= outreal3_offset AFTER 2 ns;

  outreal3_1 <= std_logic_vector(outreal3);

  drift_SD2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_SD2
  drift_SD2_fileread: PROCESS (drift_SD2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_SD2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_SD2 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_SD2_fileread;

  -- holdData reg for drift_SD2
  stimuli_drift_SD2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_SD2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_SD2 <= rawData_drift_SD2;
    END IF;
  END PROCESS stimuli_drift_SD2_process;

  stimuli_drift_SD2_1: PROCESS (rawData_drift_SD2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_SD2_offset <= holdData_drift_SD2;
    ELSE
      drift_SD2_offset <= rawData_drift_SD2;
    END IF;
  END PROCESS stimuli_drift_SD2_1;

  drift_SD2 <= drift_SD2_offset AFTER 2 ns;

  drift_SD2_1 <= std_logic_vector(drift_SD2);

  drift_FD2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_FD2
  drift_FD2_fileread: PROCESS (drift_FD2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_FD2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_FD2 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_FD2_fileread;

  -- holdData reg for drift_FD2
  stimuli_drift_FD2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_FD2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_FD2 <= rawData_drift_FD2;
    END IF;
  END PROCESS stimuli_drift_FD2_process;

  stimuli_drift_FD2_1: PROCESS (rawData_drift_FD2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_FD2_offset <= holdData_drift_FD2;
    ELSE
      drift_FD2_offset <= rawData_drift_FD2;
    END IF;
  END PROCESS stimuli_drift_FD2_1;

  drift_FD2 <= drift_FD2_offset AFTER 2 ns;

  drift_FD2_1 <= std_logic_vector(drift_FD2);

  powerbot2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powerbot2
  powerbot2_fileread: PROCESS (powerbot2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powerbot2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powerbot2 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powerbot2_fileread;

  -- holdData reg for powerbot2
  stimuli_powerbot2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powerbot2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powerbot2 <= rawData_powerbot2;
    END IF;
  END PROCESS stimuli_powerbot2_process;

  stimuli_powerbot2_1: PROCESS (rawData_powerbot2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powerbot2_offset <= holdData_powerbot2;
    ELSE
      powerbot2_offset <= rawData_powerbot2;
    END IF;
  END PROCESS stimuli_powerbot2_1;

  powerbot2 <= powerbot2_offset AFTER 2 ns;

  powerbot2_1 <= std_logic_vector(powerbot2);

  powertop2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powertop2
  powertop2_fileread: PROCESS (powertop2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powertop2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powertop2 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powertop2_fileread;

  -- holdData reg for powertop2
  stimuli_powertop2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powertop2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powertop2 <= rawData_powertop2;
    END IF;
  END PROCESS stimuli_powertop2_process;

  stimuli_powertop2_1: PROCESS (rawData_powertop2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powertop2_offset <= holdData_powertop2;
    ELSE
      powertop2_offset <= rawData_powertop2;
    END IF;
  END PROCESS stimuli_powertop2_1;

  powertop2 <= powertop2_offset AFTER 2 ns;

  powertop2_1 <= std_logic_vector(powertop2);

  outimag2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outimag2
  outimag2_fileread: PROCESS (outimag2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outimag2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outimag2 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outimag2_fileread;

  -- holdData reg for outimag2
  stimuli_outimag2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outimag2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outimag2 <= rawData_outimag2;
    END IF;
  END PROCESS stimuli_outimag2_process;

  stimuli_outimag2_1: PROCESS (rawData_outimag2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outimag2_offset <= holdData_outimag2;
    ELSE
      outimag2_offset <= rawData_outimag2;
    END IF;
  END PROCESS stimuli_outimag2_1;

  outimag2 <= outimag2_offset AFTER 2 ns;

  outimag2_1 <= std_logic_vector(outimag2);

  outreal2_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outreal2
  outreal2_fileread: PROCESS (outreal2_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outreal2.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outreal2 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outreal2_fileread;

  -- holdData reg for outreal2
  stimuli_outreal2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outreal2 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outreal2 <= rawData_outreal2;
    END IF;
  END PROCESS stimuli_outreal2_process;

  stimuli_outreal2_1: PROCESS (rawData_outreal2, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outreal2_offset <= holdData_outreal2;
    ELSE
      outreal2_offset <= rawData_outreal2;
    END IF;
  END PROCESS stimuli_outreal2_1;

  outreal2 <= outreal2_offset AFTER 2 ns;

  outreal2_1 <= std_logic_vector(outreal2);

  drift_SD1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_SD1
  drift_SD1_fileread: PROCESS (drift_SD1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_SD1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_SD1 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_SD1_fileread;

  -- holdData reg for drift_SD1
  stimuli_drift_SD1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_SD1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_SD1 <= rawData_drift_SD1;
    END IF;
  END PROCESS stimuli_drift_SD1_process;

  stimuli_drift_SD1_1: PROCESS (rawData_drift_SD1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_SD1_offset <= holdData_drift_SD1;
    ELSE
      drift_SD1_offset <= rawData_drift_SD1;
    END IF;
  END PROCESS stimuli_drift_SD1_1;

  drift_SD1 <= drift_SD1_offset AFTER 2 ns;

  drift_SD1_1 <= std_logic_vector(drift_SD1);

  drift_FD1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for drift_FD1
  drift_FD1_fileread: PROCESS (drift_FD1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "drift_FD1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_drift_FD1 <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_FD1_fileread;

  -- holdData reg for drift_FD1
  stimuli_drift_FD1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_drift_FD1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_drift_FD1 <= rawData_drift_FD1;
    END IF;
  END PROCESS stimuli_drift_FD1_process;

  stimuli_drift_FD1_1: PROCESS (rawData_drift_FD1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      drift_FD1_offset <= holdData_drift_FD1;
    ELSE
      drift_FD1_offset <= rawData_drift_FD1;
    END IF;
  END PROCESS stimuli_drift_FD1_1;

  drift_FD1 <= drift_FD1_offset AFTER 2 ns;

  drift_FD1_1 <= std_logic_vector(drift_FD1);

  powerbot1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powerbot1
  powerbot1_fileread: PROCESS (powerbot1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powerbot1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powerbot1 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powerbot1_fileread;

  -- holdData reg for powerbot1
  stimuli_powerbot1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powerbot1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powerbot1 <= rawData_powerbot1;
    END IF;
  END PROCESS stimuli_powerbot1_process;

  stimuli_powerbot1_1: PROCESS (rawData_powerbot1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powerbot1_offset <= holdData_powerbot1;
    ELSE
      powerbot1_offset <= rawData_powerbot1;
    END IF;
  END PROCESS stimuli_powerbot1_1;

  powerbot1 <= powerbot1_offset AFTER 2 ns;

  powerbot1_1 <= std_logic_vector(powerbot1);

  powertop1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for powertop1
  powertop1_fileread: PROCESS (powertop1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "powertop1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_powertop1 <= unsigned(read_data(31 DOWNTO 0));
  END PROCESS powertop1_fileread;

  -- holdData reg for powertop1
  stimuli_powertop1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_powertop1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_powertop1 <= rawData_powertop1;
    END IF;
  END PROCESS stimuli_powertop1_process;

  stimuli_powertop1_1: PROCESS (rawData_powertop1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      powertop1_offset <= holdData_powertop1;
    ELSE
      powertop1_offset <= rawData_powertop1;
    END IF;
  END PROCESS stimuli_powertop1_1;

  powertop1 <= powertop1_offset AFTER 2 ns;

  powertop1_1 <= std_logic_vector(powertop1);

  outimag1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outimag1
  outimag1_fileread: PROCESS (outimag1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outimag1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outimag1 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outimag1_fileread;

  -- holdData reg for outimag1
  stimuli_outimag1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outimag1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outimag1 <= rawData_outimag1;
    END IF;
  END PROCESS stimuli_outimag1_process;

  stimuli_outimag1_1: PROCESS (rawData_outimag1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outimag1_offset <= holdData_outimag1;
    ELSE
      outimag1_offset <= rawData_outimag1;
    END IF;
  END PROCESS stimuli_outimag1_1;

  outimag1 <= outimag1_offset AFTER 2 ns;

  outimag1_1 <= std_logic_vector(outimag1);

  
  outreal1_active <= '1' WHEN outreal1_addr /= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  outreal1_enb <= outreal1_active AND (rdEnb AND tb_enb);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13107199
  outreal1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      outreal1_addr <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF outreal1_enb = '1' THEN
        IF outreal1_addr >= to_unsigned(16#C7FFFF#, 24) THEN 
          outreal1_addr <= to_unsigned(16#000000#, 24);
        ELSE 
          outreal1_addr <= outreal1_addr + to_unsigned(16#000001#, 24);
        END IF;
      END IF;
    END IF;
  END PROCESS outreal1_process;


  outreal1_addr_delay_1 <= outreal1_addr AFTER 1 ns;

  -- Data source for outreal1
  outreal1_fileread: PROCESS (outreal1_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "outreal1.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_outreal1 <= signed(read_data(31 DOWNTO 0));
  END PROCESS outreal1_fileread;

  -- holdData reg for outreal1
  stimuli_outreal1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_outreal1 <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_outreal1 <= rawData_outreal1;
    END IF;
  END PROCESS stimuli_outreal1_process;

  stimuli_outreal1_1: PROCESS (rawData_outreal1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      outreal1_offset <= holdData_outreal1;
    ELSE
      outreal1_offset <= rawData_outreal1;
    END IF;
  END PROCESS stimuli_outreal1_1;

  outreal1_1 <= outreal1_offset AFTER 2 ns;

  outreal1_2 <= std_logic_vector(outreal1_1);

  snkDonen <=  NOT snkDone;

  resetn <=  NOT reset;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  enb <= rdEnb AFTER 2 ns;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  drift_enb <= ce_out AND drift_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 13107199
  drift_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      drift_addr <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF drift_enb = '1' THEN
        IF drift_addr >= to_unsigned(16#C7FFFF#, 24) THEN 
          drift_addr <= to_unsigned(16#000000#, 24);
        ELSE 
          drift_addr <= drift_addr + to_unsigned(16#000001#, 24);
        END IF;
      END IF;
    END IF;
  END PROCESS drift_2_process;


  
  drift_lastAddr <= '1' WHEN drift_addr >= to_unsigned(16#C7FFFF#, 24) ELSE
      '0';

  drift_done <= drift_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF drift_done_enb = '1' THEN
        check1_done <= drift_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check11_done AND (check10_done AND (check9_done AND (check8_done AND (check7_done AND (check6_done AND (check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)))))))));

  drift_signed <= signed(drift);

  drift_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for drift_expected
  drift_expected_fileread: PROCESS (drift_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "drift_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    drift_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS drift_expected_fileread;

  drift_ref <= drift_expected;

  drift_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      drift_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND drift_signed /= drift_ref THEN
        drift_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in drift_signed: Expected " & to_hex(drift_ref) & (" Actual " & to_hex(drift_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS drift_signed_checker;

  have_lock_out_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for have_lock_out_expected
  have_lock_out_expected_fileread: PROCESS (have_lock_out_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "have_lock_out_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    have_lock_out_expected <= read_data;
  END PROCESS have_lock_out_expected_fileread;

  have_lock_out_ref <= have_lock_out_expected;

  have_lock_out_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      have_lock_out_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND have_lock_out /= have_lock_out_ref THEN
        have_lock_out_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in have_lock_out: Expected " & to_hex(have_lock_out_ref) & (" Actual " & to_hex(have_lock_out))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS have_lock_out_checker;

  foutreal1_signed <= signed(foutreal1);

  foutreal1_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutreal1_expected
  foutreal1_expected_fileread: PROCESS (foutreal1_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutreal1_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutreal1_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutreal1_expected_fileread;

  foutreal1_ref <= foutreal1_expected;

  foutreal1_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutreal1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutreal1_signed /= foutreal1_ref THEN
        foutreal1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutreal1_signed: Expected " & to_hex(foutreal1_ref) & (" Actual " & to_hex(foutreal1_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutreal1_signed_checker;

  foutimag1_signed <= signed(foutimag1);

  foutimag1_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutimag1_expected
  foutimag1_expected_fileread: PROCESS (foutimag1_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutimag1_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutimag1_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutimag1_expected_fileread;

  foutimag1_ref <= foutimag1_expected;

  foutimag1_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutimag1_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutimag1_signed /= foutimag1_ref THEN
        foutimag1_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutimag1_signed: Expected " & to_hex(foutimag1_ref) & (" Actual " & to_hex(foutimag1_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutimag1_signed_checker;

  foutreal2_signed <= signed(foutreal2);

  foutreal2_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutreal2_expected
  foutreal2_expected_fileread: PROCESS (foutreal2_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutreal2_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutreal2_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutreal2_expected_fileread;

  foutreal2_ref <= foutreal2_expected;

  foutreal2_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutreal2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutreal2_signed /= foutreal2_ref THEN
        foutreal2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutreal2_signed: Expected " & to_hex(foutreal2_ref) & (" Actual " & to_hex(foutreal2_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutreal2_signed_checker;

  foutimag2_signed <= signed(foutimag2);

  foutimag2_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutimag2_expected
  foutimag2_expected_fileread: PROCESS (foutimag2_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutimag2_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutimag2_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutimag2_expected_fileread;

  foutimag2_ref <= foutimag2_expected;

  foutimag2_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutimag2_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutimag2_signed /= foutimag2_ref THEN
        foutimag2_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutimag2_signed: Expected " & to_hex(foutimag2_ref) & (" Actual " & to_hex(foutimag2_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutimag2_signed_checker;

  foutreal3_signed <= signed(foutreal3);

  foutreal3_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutreal3_expected
  foutreal3_expected_fileread: PROCESS (foutreal3_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutreal3_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutreal3_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutreal3_expected_fileread;

  foutreal3_ref <= foutreal3_expected;

  foutreal3_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutreal3_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutreal3_signed /= foutreal3_ref THEN
        foutreal3_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutreal3_signed: Expected " & to_hex(foutreal3_ref) & (" Actual " & to_hex(foutreal3_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutreal3_signed_checker;

  foutimag3_signed <= signed(foutimag3);

  foutimag3_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutimag3_expected
  foutimag3_expected_fileread: PROCESS (foutimag3_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutimag3_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutimag3_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutimag3_expected_fileread;

  foutimag3_ref <= foutimag3_expected;

  foutimag3_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutimag3_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutimag3_signed /= foutimag3_ref THEN
        foutimag3_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutimag3_signed: Expected " & to_hex(foutimag3_ref) & (" Actual " & to_hex(foutimag3_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutimag3_signed_checker;

  foutreal4_signed <= signed(foutreal4);

  foutreal4_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutreal4_expected
  foutreal4_expected_fileread: PROCESS (foutreal4_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutreal4_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutreal4_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutreal4_expected_fileread;

  foutreal4_ref <= foutreal4_expected;

  foutreal4_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutreal4_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutreal4_signed /= foutreal4_ref THEN
        foutreal4_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutreal4_signed: Expected " & to_hex(foutreal4_ref) & (" Actual " & to_hex(foutreal4_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutreal4_signed_checker;

  foutimag4_signed <= signed(foutimag4);

  foutimag4_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for foutimag4_expected
  foutimag4_expected_fileread: PROCESS (foutimag4_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "foutimag4_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(31 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    foutimag4_expected <= signed(read_data(31 DOWNTO 0));
  END PROCESS foutimag4_expected_fileread;

  foutimag4_ref <= foutimag4_expected;

  foutimag4_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      foutimag4_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND foutimag4_signed /= foutimag4_ref THEN
        foutimag4_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in foutimag4_signed: Expected " & to_hex(foutimag4_ref) & (" Actual " & to_hex(foutimag4_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS foutimag4_signed_checker;

  fout_ready_addr_delay_1 <= drift_addr AFTER 1 ns;

  -- Data source for fout_ready_expected
  fout_ready_expected_fileread: PROCESS (fout_ready_addr_delay_1, tb_enb, ce_out)
    FILE fp: TEXT open READ_MODE is "fout_ready_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF ce_out = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    fout_ready_expected <= read_data;
  END PROCESS fout_ready_expected_fileread;

  fout_ready_ref <= fout_ready_expected;

  fout_ready_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      fout_ready_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND fout_ready /= fout_ready_ref THEN
        fout_ready_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in fout_ready: Expected " & to_hex(fout_ready_ref) & (" Actual " & to_hex(fout_ready))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS fout_ready_checker;

  testFailure <= fout_ready_testFailure OR (foutimag4_testFailure OR (foutreal4_testFailure OR (foutimag3_testFailure OR (foutreal3_testFailure OR (foutimag2_testFailure OR (foutreal2_testFailure OR (foutimag1_testFailure OR (foutreal1_testFailure OR (drift_testFailure OR have_lock_out_testFailure)))))))));

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

